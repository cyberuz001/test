from flask import Flask, request, jsonify
from flask_cors import CORS
from pymongo import MongoClient
from datetime import datetime, timedelta
from bson import ObjectId
import os
import requests
import google.generativeai as genai

# === Flask ===
app = Flask(__name__)
CORS(app)

# === MongoDB ===
MONGODB_URI = os.getenv("MONGODB_URI", "mongodb+srv://user8123:515XFPhm9s1ePZ8L@user.etl6mgw.mongodb.net/?retryWrites=true&w=majority&appName=user")
client = MongoClient(
    MONGODB_URI,
    tls=True,
    tlsAllowInvalidCertificates=True,
    serverSelectionTimeoutMS=30000,
    connectTimeoutMS=30000,
    socketTimeoutMS=30000
)
db = client['game_market']
users_collection = db['users']
items_collection = db['items']
purchases_collection = db['purchases']
chats_collection = db['chats']
settings_collection = db['settings']
ads_collection = db['advertisements']
user_listings_collection = db['user_listings']
support_sessions_collection = db['support_sessions']

# === Telegram Bot Configuration ===
BOT_TOKEN = os.getenv("BOT_TOKEN", "7474878491:AAE-QLdJhJJJJJJJJJJJJJJJJJJJJJJJJJJJ")  # Replace with your actual bot token
TELEGRAM_API_URL = f"https://api.telegram.org/bot{BOT_TOKEN}"

# === Gemini AI ===
GOOGLE_API_KEY = os.getenv("GOOGLE_AI_API_KEY", "your-api-key-here")
genai.configure(api_key=GOOGLE_API_KEY)
model = genai.GenerativeModel("gemini-pro")

# === Admin IDs ===
ADMIN_IDS = {
    'GENERAL_ADMIN': 987654321,  # Replace with your actual Telegram ID
    'ALLOWED_ADMINS': [987654321, 123456789]
}

# === Helper Functions ===
def serialize_doc(doc):
    if isinstance(doc, list):
        return [serialize_doc(d) for d in doc]
    elif isinstance(doc, dict):
        result = {}
        for k, v in doc.items():
            if isinstance(v, ObjectId):
                result[k] = str(v)
            elif isinstance(v, datetime):
                result[k] = v.isoformat()
            elif isinstance(v, (dict, list)):
                result[k] = serialize_doc(v)
            else:
                result[k] = v
        return result
    else:
        return doc

def is_admin(telegram_id):
    if telegram_id in ADMIN_IDS['ALLOWED_ADMINS']:
        return True
    user = users_collection.find_one({'telegram_id': telegram_id})
    return user and user.get('role') in ['admin', 'general_admin', 'supporter_admin', 'buyer_admin']

def is_general_admin(telegram_id):
    if telegram_id == ADMIN_IDS['GENERAL_ADMIN']:
        return True
    user = users_collection.find_one({'telegram_id': telegram_id})
    return user and user.get('role') == 'general_admin'

def get_user_role(telegram_id):
    if telegram_id == ADMIN_IDS['GENERAL_ADMIN']:
        return 'general_admin'
    user = users_collection.find_one({'telegram_id': telegram_id})
    return user.get('role', 'user') if user else 'user'

def is_user_online(telegram_id):
    user = users_collection.find_one({'telegram_id': telegram_id})
    if not user:
        return False
    
    last_active = user.get('last_active')
    if not last_active:
        return False
    
    # Consider user online if active within last 5 minutes
    return (datetime.now() - last_active).total_seconds() < 300

# === Payment Functions ===
def create_invoice_link(title, description, payload, currency, prices):
    """Create Telegram Stars invoice link"""
    try:
        if not BOT_TOKEN or BOT_TOKEN == "7474878491:AAE-QLdJhJJJJJJJJJJJJJJJJJJJJJJJJJJJ":
            # Return mock invoice for testing
            return f"https://t.me/invoice/{payload}"
        
        url = f"{TELEGRAM_API_URL}/createInvoiceLink"
        data = {
            "title": title,
            "description": description,
            "payload": payload,
            "provider_token": "",  # Empty for Telegram Stars
            "currency": currency,
            "prices": prices
        }
        
        response = requests.post(url, json=data, timeout=10)
        result = response.json()
        
        if result.get('ok'):
            return result['result']
        else:
            raise Exception(f"Telegram API error: {result.get('description', 'Unknown error')}")
    except Exception as e:
        # Fallback for testing - simulate successful payment
        return f"https://t.me/invoice/{payload}"

# === ROUTES ===

@app.route('/api/test')
def test():
    try:
        client.admin.command('ping')
        return jsonify({'status': 'success', 'message': 'API va MongoDB ishlayapti'})
    except Exception as e:
        return jsonify({'status': 'error', 'message': str(e)}), 500

@app.route('/api/users/register', methods=['POST'])
def register_user():
    try:
        data = request.get_json()
        telegram_id = data.get("telegram_id")
        if not telegram_id:
            return jsonify({"error": "telegram_id kerak"}), 400
        
        user = users_collection.find_one({"telegram_id": telegram_id})
        now = datetime.now()
        
        update_data = {
            "first_name": data.get("first_name"),
            "last_name": data.get("last_name"),
            "username": data.get("username"),
            "last_active": now,
            "is_online": True
        }
        
        if data.get("photo_url"):
            update_data["photo_url"] = data.get("photo_url")
        
        if user:
            users_collection.update_one({"telegram_id": telegram_id}, {"$set": update_data})
            user = users_collection.find_one({"telegram_id": telegram_id})
        else:
            role = get_user_role(telegram_id)
            new_user = {
                "telegram_id": telegram_id,
                "first_name": data.get("first_name"),
                "last_name": data.get("last_name"),
                "username": data.get("username"),
                "photo_url": data.get("photo_url"),
                "role": role,
                "balance": 1000.0 if role == "general_admin" else 0.0,
                "language": "uz",
                "created_at": now,
                "last_active": now,
                "is_online": True,
                "is_banned": False,
                "total_sales": 0,
                "total_purchases": 0
            }
            users_collection.insert_one(new_user)
            user = new_user
        
        return jsonify({"user": serialize_doc(user)})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/users/<int:telegram_id>', methods=['GET'])
def get_user(telegram_id):
    try:
        user = users_collection.find_one({'telegram_id': telegram_id})
        if not user:
            return jsonify({'error': 'Foydalanuvchi topilmadi'}), 404
        return jsonify({'user': serialize_doc(user)})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/users/update-activity', methods=['POST'])
def update_user_activity():
    try:
        data = request.get_json()
        telegram_id = data.get("telegram_id")
        
        if not telegram_id:
            return jsonify({"error": "telegram_id kerak"}), 400
        
        users_collection.update_one(
            {"telegram_id": telegram_id},
            {"$set": {"last_active": datetime.now(), "is_online": True}}
        )
        
        return jsonify({"message": "Activity updated"})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/users/set-offline', methods=['POST'])
def set_user_offline():
    try:
        data = request.get_json()
        telegram_id = data.get("telegram_id")
        
        if not telegram_id:
            return jsonify({"error": "telegram_id kerak"}), 400
        
        users_collection.update_one(
            {"telegram_id": telegram_id},
            {"$set": {"is_online": False}}
        )
        
        return jsonify({"message": "User set offline"})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/payment/create-invoice', methods=['POST'])
def create_payment_invoice():
    try:
        data = request.get_json()
        telegram_id = data.get("telegram_id")
        amount = float(data.get("amount", 0))
        stars = int(data.get("stars", 0))
        
        if not telegram_id or amount <= 0 or stars <= 0:
            return jsonify({"error": "Noto'g'ri ma'lumot"}), 400
        
        # Create invoice for Telegram Stars
        title = f"{stars} Stars sotib olish"
        description = f"{stars} ta yulduz ${amount} ga"
        payload = f"stars_{telegram_id}_{stars}_{int(amount * 100)}"
        currency = "XTR"  # Telegram Stars currency code
        prices = [{"label": f"{stars} Stars", "amount": int(amount * 100)}]
        
        try:
            invoice_link = create_invoice_link(title, description, payload, currency, prices)
            
            return jsonify({
                "invoice_link": invoice_link,
                "payload": payload
            })
        except Exception as e:
            # For testing purposes, simulate successful payment
            users_collection.update_one(
                {"telegram_id": telegram_id},
                {"$inc": {"balance": stars}, "$set": {"last_active": datetime.now()}}
            )
            
            return jsonify({
                "invoice_link": None,
                "payload": payload,
                "test_mode": True,
                "message": f"{stars} yulduz test rejimida qo'shildi"
            })
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/payment/webhook', methods=['POST'])
def payment_webhook():
    try:
        data = request.get_json()
        
        if data.get('pre_checkout_query'):
            return jsonify({"ok": True})
        
        if data.get('message') and data['message'].get('successful_payment'):
            payment = data['message']['successful_payment']
            payload = payment.get('invoice_payload', '')
            
            parts = payload.split('_')
            if len(parts) >= 4 and parts[0] == 'stars':
                telegram_id = int(parts[1])
                stars = int(parts[2])
                
                users_collection.update_one(
                    {"telegram_id": telegram_id},
                    {"$inc": {"balance": stars}, "$set": {"last_active": datetime.now()}}
                )
                
                return jsonify({"ok": True})
        
        return jsonify({"ok": True})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/users/add-balance', methods=['POST'])
def add_balance():
    try:
        data = request.get_json()
        telegram_id = data.get("telegram_id")
        amount = float(data.get("amount", 0))
        
        if not telegram_id or amount <= 0:
            return jsonify({"error": "Noto'g'ri ma'lumot"}), 400
        
        result = users_collection.update_one(
            {"telegram_id": telegram_id},
            {"$inc": {"balance": amount}, "$set": {"last_active": datetime.now()}}
        )
        
        if result.matched_count == 0:
            return jsonify({"error": "Foydalanuvchi topilmadi"}), 404
        
        return jsonify({"message": f"{amount} yulduz qo'shildi"})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# Admin Management
@app.route('/api/admin/assign-role', methods=['POST'])
def assign_admin_role():
    try:
        data = request.get_json()
        admin_id = data.get("admin_telegram_id")
        target_id = data.get("target_telegram_id")
        role = data.get("role")
        
        if not is_general_admin(admin_id):
            return jsonify({"error": "Ruxsat yo'q"}), 403
        
        if role not in ['user', 'supporter_admin', 'buyer_admin', 'admin']:
            return jsonify({"error": "Noto'g'ri rol"}), 400
        
        users_collection.update_one(
            {"telegram_id": target_id},
            {"$set": {"role": role, "updated_at": datetime.now()}},
            upsert=True
        )
        
        return jsonify({"message": f"Rol {role} tayinlandi"})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/admin/settings', methods=['GET'])
def get_admin_settings():
    try:
        settings = list(settings_collection.find({}))
        return jsonify({"settings": serialize_doc(settings)})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/admin/settings', methods=['POST'])
def update_admin_settings():
    try:
        data = request.get_json()
        admin_id = data.get("admin_telegram_id")
        
        if not is_general_admin(admin_id):
            return jsonify({"error": "Ruxsat yo'q"}), 403
        
        setting_type = data.get("type")
        setting_data = data.get("data")
        
        settings_collection.update_one(
            {"type": setting_type},
            {"$set": {"data": setting_data, "updated_at": datetime.now()}},
            upsert=True
        )
        
        return jsonify({"message": "Sozlamalar yangilandi"})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# Support Chat System
@app.route('/api/support/get-available-admin', methods=['POST'])
def get_available_support_admin():
    try:
        data = request.get_json()
        user_id = data.get("user_telegram_id")
        
        # Find available supporter admin
        supporter_admins = list(users_collection.find({
            "role": "supporter_admin",
            "is_online": True
        }))
        
        if not supporter_admins:
            return jsonify({"admin": None, "message": "Hozirda admin mavjud emas"})
        
        # Check if admin is busy with other users
        available_admin = None
        for admin in supporter_admins:
            active_sessions = support_sessions_collection.count_documents({
                "admin_telegram_id": admin["telegram_id"],
                "status": "active"
            })
            
            if active_sessions < 3:  # Max 3 concurrent sessions per admin
                available_admin = admin
                break
        
        if not available_admin:
            return jsonify({"admin": None, "message": "Adminlar band, iltimos kuting"})
        
        # Create or update support session
        support_sessions_collection.update_one(
            {"user_telegram_id": user_id},
            {
                "$set": {
                    "admin_telegram_id": available_admin["telegram_id"],
                    "status": "active",
                    "created_at": datetime.now(),
                    "updated_at": datetime.now()
                }
            },
            upsert=True
        )
        
        return jsonify({"admin": serialize_doc(available_admin)})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/support/close-session', methods=['POST'])
def close_support_session():
    try:
        data = request.get_json()
        admin_id = data.get("admin_telegram_id")
        user_id = data.get("user_telegram_id")
        
        if not is_admin(admin_id):
            return jsonify({"error": "Ruxsat yo'q"}), 403
        
        support_sessions_collection.update_one(
            {"user_telegram_id": user_id, "admin_telegram_id": admin_id},
            {"$set": {"status": "closed", "closed_at": datetime.now()}}
        )
        
        return jsonify({"message": "Session yopildi"})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/chat/send', methods=['POST'])
def send_chat():
    try:
        data = request.get_json()
        telegram_id = data.get("user_telegram_id")
        message = data.get("message")
        chat_id = data.get("chat_id") or str(ObjectId())
        language = data.get("language", "uz")
        
        if not telegram_id or not message:
            return jsonify({"error": "user_telegram_id va message kerak"}), 400
        
        # Update user activity
        users_collection.update_one(
            {"telegram_id": telegram_id},
            {"$set": {"last_active": datetime.now(), "is_online": True}}
        )
        
        # Save user message
        chats_collection.insert_one({
            "chat_id": chat_id,
            "user_telegram_id": telegram_id,
            "message": message,
            "sender_type": "user",
            "timestamp": datetime.now()
        })
        
        # Check if user has active support session
        support_session = support_sessions_collection.find_one({
            "user_telegram_id": telegram_id,
            "status": "active"
        })
        
        if support_session:
            admin_id = support_session["admin_telegram_id"]
            admin = users_collection.find_one({"telegram_id": admin_id})
            
            if admin and is_user_online(admin_id):
                # Forward message to admin (in real implementation, you'd use WebSocket or similar)
                return jsonify({
                    "chat_id": chat_id,
                    "admin_response": "Xabaringiz adminga yuborildi",
                    "admin_info": serialize_doc(admin)
                })
            else:
                # Admin is offline
                ai_response = get_ai_response_by_language(
                    "Admin hozir mavjud emas. Iltimos, biroz kuting yoki keyinroq urinib ko'ring.",
                    language
                )
        else:
            # No active session, use AI
            ai_response = get_ai_response_by_language(message, language)
        
        # Save AI response
        chats_collection.insert_one({
            "chat_id": chat_id,
            "user_telegram_id": telegram_id,
            "message": ai_response,
            "sender_type": "ai",
            "timestamp": datetime.now()
        })
        
        return jsonify({"chat_id": chat_id, "ai_response": ai_response})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

def get_ai_response_by_language(message, language):
    """Generate AI response in user's language"""
    try:
        contexts = {
            'uz': "Siz Game Market AI yordamchisisiz. O'zbek tilida javob bering. O'yin akkauntlari bozori haqida savollarni javoblang. Ilovadan qanday foydalanish haqida to'liq ma'lumot bering.",
            'ru': "Ð’Ñ‹ Ð¿Ð¾Ð¼Ð¾Ñ‰Ð½Ð¸Ðº Game Market AI. ÐžÑ‚Ð²ÐµÑ‡Ð°Ð¹Ñ‚Ðµ Ð½Ð° Ñ€ÑƒÑÑÐºÐ¾Ð¼ ÑÐ·Ñ‹ÐºÐµ. ÐžÑ‚Ð²ÐµÑ‡Ð°Ð¹Ñ‚Ðµ Ð½Ð° Ð²Ð¾Ð¿Ñ€Ð¾ÑÑ‹ Ð¾ Ñ€Ñ‹Ð½ÐºÐµ Ð¸Ð³Ñ€Ð¾Ð²Ñ‹Ñ… Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ð¾Ð². ÐŸÑ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ Ð¿Ð¾Ð»Ð½ÑƒÑŽ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾ Ñ‚Ð¾Ð¼, ÐºÐ°Ðº Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ.",
            'en': "You are Game Market AI assistant. Respond in English. Answer questions about the gaming accounts marketplace. Provide complete information about how to use the app.",
            'ja': "ã‚ãªãŸã¯Game Market AIã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚æ—¥æœ¬èªžã§å›žç­”ã—ã¦ãã ã•ã„ã€‚ã‚²ãƒ¼ãƒ ã‚¢ã‚«ã‚¦ãƒ³ãƒˆå¸‚å ´ã«é–¢ã™ã‚‹è³ªå•ã«ç­”ãˆã¦ãã ã•ã„ã€‚ã‚¢ãƒ—ãƒªã®ä½¿ç”¨æ–¹æ³•ã«ã¤ã„ã¦å®Œå…¨ãªæƒ…å ±ã‚’æä¾›ã—ã¦ãã ã•ã„ã€‚"
        }
        
        context = contexts.get(language, contexts['uz'])
        
        # Add usage instructions
        usage_instructions = {
            'uz': """
Game Market ilovasidan foydalanish bo'yicha qo'llanma:

ðŸ  Bosh sahifa: Barcha mavjud o'yin akkauntlarini ko'ring
â­ Yulduzlar: Telegram Stars orqali yulduz sotib oling
ðŸ“š Tarix: O'z tranzaksiyalaringizni kuzating
ðŸ‘¤ Profil: Shaxsiy ma'lumotlaringiz va sozlamalar

ðŸ’° Account sotish:
1. Profil sahifasiga o'ting
2. "Account sotish" tugmasini bosing
3. O'yin kategoriyasini tanlang
4. Account ma'lumotlarini kiriting
5. 1-3 ta rasm yuklang
6. Narx va muddat belgilang

ðŸ›’ Account sotib olish:
1. Kerakli accountni tanlang
2. "Sotib olish" tugmasini bosing
3. Yulduzlar bilan to'lang

ðŸ“¢ Reklama berish:
1. Avval account e'lonini yarating
2. "Reklama berish" tugmasini bosing
3. Reklama paketini tanlang
4. To'lov qiling

â“ Yordam kerak bo'lsa, shu chatdan foydalaning!
            """,
            'ru': """
Ð ÑƒÐºÐ¾Ð²Ð¾Ð´ÑÑ‚Ð²Ð¾ Ð¿Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸ÑŽ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ Game Market:

ðŸ  Ð“Ð»Ð°Ð²Ð½Ð°Ñ: ÐŸÑ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€ Ð²ÑÐµÑ… Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ñ… Ð¸Ð³Ñ€Ð¾Ð²Ñ‹Ñ… Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ð¾Ð²
â­ Ð—Ð²ÐµÐ·Ð´Ñ‹: ÐŸÐ¾ÐºÑƒÐ¿ÐºÐ° Ð·Ð²ÐµÐ·Ð´ Ñ‡ÐµÑ€ÐµÐ· Telegram Stars
ðŸ“š Ð˜ÑÑ‚Ð¾Ñ€Ð¸Ñ: ÐžÑ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð½Ð¸Ðµ Ð²Ð°ÑˆÐ¸Ñ… Ñ‚Ñ€Ð°Ð½Ð·Ð°ÐºÑ†Ð¸Ð¹
ðŸ‘¤ ÐŸÑ€Ð¾Ñ„Ð¸Ð»ÑŒ: Ð›Ð¸Ñ‡Ð½Ð°Ñ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ Ð¸ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸

ðŸ’° ÐŸÑ€Ð¾Ð´Ð°Ð¶Ð° Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ð°:
1. ÐŸÐµÑ€ÐµÐ¹Ð´Ð¸Ñ‚Ðµ Ð² Ð¿Ñ€Ð¾Ñ„Ð¸Ð»ÑŒ
2. ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ "ÐŸÑ€Ð¾Ð´Ð°Ñ‚ÑŒ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚"
3. Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸ÑŽ Ð¸Ð³Ñ€Ñ‹
4. Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾Ð± Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ðµ
5. Ð—Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚Ðµ 1-3 Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ
6. Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚Ðµ Ñ†ÐµÐ½Ñƒ Ð¸ ÑÑ€Ð¾Ðº

ðŸ›’ ÐŸÐ¾ÐºÑƒÐ¿ÐºÐ° Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚Ð°:
1. Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð½ÑƒÐ¶Ð½Ñ‹Ð¹ Ð°ÐºÐºÐ°ÑƒÐ½Ñ‚
2. ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ "ÐšÑƒÐ¿Ð¸Ñ‚ÑŒ"
3. ÐžÐ¿Ð»Ð°Ñ‚Ð¸Ñ‚Ðµ Ð·Ð²ÐµÐ·Ð´Ð°Ð¼Ð¸

ðŸ“¢ Ð Ð°Ð·Ð¼ÐµÑ‰ÐµÐ½Ð¸Ðµ Ñ€ÐµÐºÐ»Ð°Ð¼Ñ‹:
1. Ð¡Ð½Ð°Ñ‡Ð°Ð»Ð° ÑÐ¾Ð·Ð´Ð°Ð¹Ñ‚Ðµ Ð¾Ð±ÑŠÑÐ²Ð»ÐµÐ½Ð¸Ðµ
2. ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ "Ð ÐµÐºÐ»Ð°Ð¼Ð°"
3. Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ñ€ÐµÐºÐ»Ð°Ð¼Ð½Ñ‹Ð¹ Ð¿Ð°ÐºÐµÑ‚
4. ÐŸÑ€Ð¾Ð¸Ð·Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¾Ð¿Ð»Ð°Ñ‚Ñƒ

â“ Ð•ÑÐ»Ð¸ Ð½ÑƒÐ¶Ð½Ð° Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒ, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ ÑÑ‚Ð¾Ñ‚ Ñ‡Ð°Ñ‚!
            """,
            'en': """
Game Market App Usage Guide:

ðŸ  Home: View all available gaming accounts
â­ Stars: Buy stars via Telegram Stars
ðŸ“š History: Track your transactions
ðŸ‘¤ Profile: Personal information and settings

ðŸ’° Selling Account:
1. Go to Profile
2. Click "Sell Account"
3. Select game category
4. Enter account details
5. Upload 1-3 images
6. Set price and duration

ðŸ›’ Buying Account:
1. Select desired account
2. Click "Buy"
3. Pay with stars

ðŸ“¢ Advertising:
1. First create an account listing
2. Click "Advertise"
3. Choose ad package
4. Make payment

â“ Need help? Use this chat!
            """,
            'ja': """
Game Marketã‚¢ãƒ—ãƒªä½¿ç”¨ã‚¬ã‚¤ãƒ‰:

ðŸ  ãƒ›ãƒ¼ãƒ : åˆ©ç”¨å¯èƒ½ãªã‚²ãƒ¼ãƒ ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’è¡¨ç¤º
â­ ã‚¹ã‚¿ãƒ¼: Telegram Starsã§ã‚¹ã‚¿ãƒ¼ã‚’è³¼å…¥
ðŸ“š å±¥æ­´: å–å¼•ã‚’è¿½è·¡
ðŸ‘¤ ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«: å€‹äººæƒ…å ±ã¨è¨­å®š

ðŸ’° ã‚¢ã‚«ã‚¦ãƒ³ãƒˆè²©å£²:
1. ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã«ç§»å‹•
2. "ã‚¢ã‚«ã‚¦ãƒ³ãƒˆè²©å£²"ã‚’ã‚¯ãƒªãƒƒã‚¯
3. ã‚²ãƒ¼ãƒ ã‚«ãƒ†ã‚´ãƒªã‚’é¸æŠž
4. ã‚¢ã‚«ã‚¦ãƒ³ãƒˆè©³ç´°ã‚’å…¥åŠ›
5. 1-3æžšã®ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
6. ä¾¡æ ¼ã¨æœŸé–“ã‚’è¨­å®š

ðŸ›’ ã‚¢ã‚«ã‚¦ãƒ³ãƒˆè³¼å…¥:
1. å¸Œæœ›ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’é¸æŠž
2. "è³¼å…¥"ã‚’ã‚¯ãƒªãƒƒã‚¯
3. ã‚¹ã‚¿ãƒ¼ã§æ”¯æ‰•ã„

ðŸ“¢ åºƒå‘Š:
1. ã¾ãšã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚¹ãƒˆã‚’ä½œæˆ
2. "åºƒå‘Š"ã‚’ã‚¯ãƒªãƒƒã‚¯
3. åºƒå‘Šãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’é¸æŠž
4. æ”¯æ‰•ã„ã‚’è¡Œã†

â“ ãƒ˜ãƒ«ãƒ—ãŒå¿…è¦ã§ã™ã‹ï¼Ÿã“ã®ãƒãƒ£ãƒƒãƒˆã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ï¼
            """
        }
        
        if "yordam" in message.lower() or "help" in message.lower() or "qanday" in message.lower():
            return usage_instructions.get(language, usage_instructions['uz'])
        
        chat = model.start_chat()
        response = chat.send_message(f"{context}\n\n{message}")
        return response.text
    except Exception as e:
        return "Xatolik yuz berdi. Iltimos, qayta urinib ko'ring."

@app.route('/api/chat/history/<int:telegram_id>', methods=['GET'])
def get_chat_history(telegram_id):
    try:
        messages = list(chats_collection.find(
            {"user_telegram_id": telegram_id}
        ).sort("timestamp", 1).limit(50))
        
        return jsonify({"messages": serialize_doc(messages)})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# Items and listings (existing code continues...)
@app.route('/api/items', methods=['GET'])
def get_items():
    try:
        category = request.args.get("category")
        query = {"status": "available"}
        
        if category and category != "All":
            query["category"] = category
        
        items = list(items_collection.find(query).sort("created_at", -1))
        return jsonify({"items": serialize_doc(items)})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/items', methods=['POST'])
def create_item():
    try:
        data = request.get_json()
        seller_id = data.get("seller_telegram_id")
        
        if not is_admin(seller_id):
            return jsonify({"error": "Ruxsat yo'q"}), 403
        
        new_item = {
            "title": data.get("title"),
            "description": data.get("description"),
            "price": data.get("price"),
            "images": data.get("images", []),
            "category": data.get("category"),
            "seller_telegram_id": seller_id,
            "is_admin_item": True,
            "login_info": {
                "login": data.get("login"),
                "password": data.get("password"),
                "additional_info": data.get("additional_info", "")
            },
            "status": "available",
            "created_at": datetime.now(),
            "updated_at": datetime.now()
        }
        
        result = items_collection.insert_one(new_item)
        new_item["_id"] = result.inserted_id
        
        return jsonify({"item": serialize_doc(new_item)})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# User Listings (Account Selling)
@app.route('/api/user-listings', methods=['POST'])
def create_user_listing():
    try:
        data = request.get_json()
        seller_id = data.get("seller_telegram_id")
        
        if not seller_id:
            return jsonify({"error": "seller_telegram_id kerak"}), 400
        
        # Check if user has enough stars for listing
        user = users_collection.find_one({"telegram_id": seller_id})
        if not user:
            return jsonify({"error": "Foydalanuvchi topilmadi"}), 404
        
        listing_cost = data.get("listing_cost", 10)  # Default 10 stars
        if user.get("balance", 0) < listing_cost:
            return jsonify({"error": "Yetarli yulduz yo'q"}), 400
        
        # Calculate expiry date
        listing_days = data.get("listing_days", 7)  # Default 7 days
        expiry_date = datetime.now() + timedelta(days=listing_days)
        
        new_listing = {
            "title": data.get("title"),
            "description": data.get("description"),
            "price": data.get("price"),
            "images": data.get("images", []),
            "category": data.get("category"),
            "seller_telegram_id": seller_id,
            "is_admin_item": False,
            "status": "available",
            "created_at": datetime.now(),
            "updated_at": datetime.now(),
            "expires_at": expiry_date,
            "listing_cost": listing_cost,
            "listing_days": listing_days
        }
        
        result = user_listings_collection.insert_one(new_listing)
        
        # Deduct stars from user balance
        users_collection.update_one(
            {"telegram_id": seller_id},
            {"$inc": {"balance": -listing_cost}}
        )
        
        new_listing["_id"] = result.inserted_id
        return jsonify({"listing": serialize_doc(new_listing)})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/user-listings/<int:telegram_id>', methods=['GET'])
def get_user_listings(telegram_id):
    try:
        listings = list(user_listings_collection.find(
            {"seller_telegram_id": telegram_id}
        ).sort("created_at", -1))
        
        return jsonify({"listings": serialize_doc(listings)})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# Advertisement System
@app.route('/api/advertisements', methods=['POST'])
def create_advertisement():
    try:
        data = request.get_json()
        user_id = data.get("user_telegram_id")
        listing_id = data.get("listing_id")
        ad_package = data.get("ad_package")
        
        if not user_id or not listing_id or not ad_package:
            return jsonify({"error": "Barcha maydonlar kerak"}), 400
        
        # Get ad package details from settings
        settings = settings_collection.find_one({"type": "ad_packages"})
        if not settings or ad_package not in settings.get("packages", {}):
            return jsonify({"error": "Noto'g'ri reklama paketi"}), 400
        
        package_info = settings["packages"][ad_package]
        cost = package_info["price"]
        duration_days = package_info["duration_days"]
        
        # Check user balance
        user = users_collection.find_one({"telegram_id": user_id})
        if not user or user.get("balance", 0) < cost:
            return jsonify({"error": "Yetarli yulduz yo'q"}), 400
        
        # Create advertisement
        expiry_date = datetime.now() + timedelta(days=duration_days)
        
        new_ad = {
            "user_telegram_id": user_id,
            "listing_id": listing_id,
            "ad_package": ad_package,
            "cost": cost,
            "duration_days": duration_days,
            "image": data.get("image"),
            "status": "active",
            "created_at": datetime.now(),
            "expires_at": expiry_date
        }
        
        result = ads_collection.insert_one(new_ad)
        
        # Deduct cost from user balance
        users_collection.update_one(
            {"telegram_id": user_id},
            {"$inc": {"balance": -cost}}
        )
        
        new_ad["_id"] = result.inserted_id
        return jsonify({"advertisement": serialize_doc(new_ad)})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/advertisements', methods=['GET'])
def get_advertisements():
    try:
        # Get active advertisements
        ads = list(ads_collection.find({
            "status": "active",
            "expires_at": {"$gt": datetime.now()}
        }).sort("created_at", -1))
        
        return jsonify({"advertisements": serialize_doc(ads)})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# Initialize default settings
def initialize_default_settings():
    try:
        # Ad packages settings
        ad_packages = {
            "type": "ad_packages",
            "packages": {
                "basic": {"price": 50, "duration_days": 3, "name": "Asosiy"},
                "premium": {"price": 100, "duration_days": 7, "name": "Premium"},
                "vip": {"price": 200, "duration_days": 14, "name": "VIP"}
            },
            "created_at": datetime.now()
        }
        
        settings_collection.update_one(
            {"type": "ad_packages"},
            {"$setOnInsert": ad_packages},
            upsert=True
        )
        
        # System settings
        system_settings = {
            "type": "system_settings",
            "admin_purchase_enabled": True,
            "buyer_admin_cost": 25,  # Stars cost for buyer admin assistance
            "created_at": datetime.now()
        }
        
        settings_collection.update_one(
            {"type": "system_settings"},
            {"$setOnInsert": system_settings},
            upsert=True
        )
        
    except Exception as e:
        print(f"Error initializing settings: {e}")

# Initialize settings on startup
initialize_default_settings()

# === WSGI ===
application = app

if __name__ == "__main__":
    app.run(debug=True, host="0.0.0.0", port=5000)
